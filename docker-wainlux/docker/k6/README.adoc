= k6 (MVP)
























































































































































































































































































































































































Clean-room implementation - no vendor code used. See link:../CLEAN_ROOM.md[CLEAN_ROOM.md].* **GrblWebStreamer**: Job preview with thumbnails* **CNCjs**: Command preview and validation* **LaserGRBL**: ImageProcessor abstraction, preview before execution* **meerk40t**: Device/Driver/Controller separation, intermediate representation (CutCode)Architecture inspired by OSS research:== Credits----Ref: DRIVER_ABSTRACTION_PLAN.adoc Phase 1 (Week 1)Next: Integrate into driver.py, create preview API endpoint.All 8 unit tests pass without hardware.- CommandSequence: Job-level collection with stats/bounds- K6CommandBuilder: Factory with 10+ pure functions- K6Command: Command dataclass with metadata- K6Opcode: Protocol opcode enum (14 constants)Key components:- Validation: Check bounds/limits before execution- Debugging: Inspect exact bytes before burning- Testing: Unit test protocol without serial device  - Preview: Generate command sequence without hardwareSeparates command generation from execution to enable:feat(k6): Add command abstraction layer for preview-driven testing----[source]== Commit Message Template* link:docker/tests/test_commands.py[Unit tests]* link:docker/k6/commands.py[Command abstraction source]* link:docker/k6/README.adoc[K6 module documentation]* link:DRIVER_ABSTRACTION_PLAN.adoc[Full 4-week implementation plan]== DocumentationThis architecture enables the entire test strategy going forward.4. Provide user feedback before commit3. Debug positioning issues in isolation2. Validate bounds/limits before burning1. Test protocol correctness without hardwareBy separating command *generation* (K6CommandBuilder) from *execution* (transport.write()), we can:**Preview = Testable Interface**> — User's key realization> "preview could preview what we then send to the driver... right? I think that is the best way forward. driver driven abstraction by preview addition."== Strategic Insight[ ] Job queue with thumbnails[ ] Material presets database[ ] Optimize graph paper speed (currently 15-20min)=== Phase 4: Protocol Refinement (Week 4)[ ] Integration tests with preview assertions----    print(f"ERROR: Exceeds limit by {bounds['max_y'] - 1520}px")if bounds['max_y'] > 1520:print(f"Pattern Y range: {bounds['min_y']} → {bounds['max_y']}")bounds = preview['bounds']preview = k6_service.preview_burn("bottom_test.png", 500, 10)----[source,python][ ] Debug bottom-out test using preview:[ ] Write unit tests for all calibration patterns=== Phase 3: Testing (Week 3)[ ] Frontend preview UI component[ ] Create `POST /api/preview` endpoint----    return seq.to_dict()        seq.add(K6CommandBuilder.build_init(2))    seq.add(K6CommandBuilder.build_init(1))            seq.add(K6CommandBuilder.build_data_packet(line_data, line_num))    for line_num, line_data in enumerate(img_array):        seq.add(K6CommandBuilder.build_job_header(...))    seq.add(K6CommandBuilder.build_framing())    seq = CommandSequence(description="Image burn preview")    # Generate commands        img_array = self.image_service.load_and_process(image_path)    # Process image (same as engrave)    """Generate command sequence without executing"""def preview_burn(self, image_path: str, power: int, depth: int) -> dict:----[source,python][ ] Add `preview_burn()` method to K6Service:=== Phase 2: Preview API (Week 2)[ ] **Verify graph paper still works** after refactor[ ] **Keep transport layer unchanged** - just swap command generationReplace inline `bytes([...])` and `protocol.build_*()` calls throughout driver.py.----send_cmd(transport, cmd.description, cmd.payload)cmd = K6CommandBuilder.build_framing()# After:send_cmd(transport, "FRAMING", payload)payload = bytes([0x21, 0x00, 0x04, 0x00])# Before:----[source,python][ ] **Refactor driver.py** to use K6CommandBuilder:=== Phase 1: Integration (Current Week)== Next Steps----}  ]    {"opcode": "0x23", "opcode_name": "JOB_HEADER", "description": "..."}    {"opcode": "0x21", "opcode_name": "FRAMING", "description": "..."},  "commands": [  },    "max_y": 1560    "height": 1600,    "width": 1600,  "bounds": {  },    "estimated_time_sec": 3608.0    "data_chunks": 1600,    "total_bytes": 320800,    "total_commands": 1604,  "stats": {  "description": "Graph paper test",{----[source,json]Frontend receives:----    return jsonify(seq.to_dict())    seq = generate_preview_from_request()def preview():@app.route('/api/preview', methods=['POST'])# Flask endpoint----[source,python]Commands serialize to JSON for web API:=== 4. API Integration----# 200006400640006703f800print(cmd.payload.hex())# See exact bytes# Payload: 11 bytes, expect_ack=True, timeout=2.0s# K6Command(BOUNDS: Preview bounds 1600×1600 @ center (867, 760))print(cmd)cmd = K6CommandBuilder.build_job_header(1600, 1600, 100, 500)----[source,python]Inspect exact bytes before execution:=== 3. Debugging----    assert bounds['min_y'] >= 0    assert bounds['max_y'] <= 1520  # Hardware limit    bounds = seq.get_bounds()        ))        center_x=800, center_y=1510  # Near bottom        width=1600, height=20, depth=10, power=500,    seq.add(K6CommandBuilder.build_job_header(    seq = CommandSequence(description="Bottom test")    """Validate bottom-out test stays within limits"""def test_bottom_out_pattern():----[source,python]Tests validate protocol correctness without serial device:=== 2. Unit Testing----    raise ValueError("Pattern exceeds Y-axis limit!")if bounds['max_y'] > 1520:bounds = seq.get_bounds()# Validate boundsprint(f"Estimated time: {seq.stats['estimated_time_sec']}s")print(f"Total commands: {seq.stats['total_commands']}")# Check what will be sent BEFORE burningseq = preview_graph_paper()# Generate command sequence----[source,python]=== 1. Preview Without Hardware== Key Benefits----python3 tests/test_commands.pycd docker-wainlux/docker----[source,bash]Run anytime:----✓ Summary generation✓ Command serialization works  ✓ Within hardware limits (max_y=1520 ≤ 1520)✓ Bounds extraction: Y range 1500 → 1520✓ CommandSequence stats: {'total_commands': 104, 'total_bytes': 20450, 'data_chunks': 100, 'estimated_time_sec': 222.99}✓ DATA packet structure correct✓ JOB_HEADER command structure correct✓ BOUNDS command structure correct  ✓ FRAMING command structure correct----[source]All 8 unit tests pass without hardware:== Test Results----seq.to_dict()  # Full serialization# JSON for API#   Y: -40 → 1560#   X: 67 → 1667# Bounds: 1600×1600 @ (867, 760)# Est. Time: 22.0s# Size: 200 bytes# Commands: 4 (0 data chunks)# Job: Test patternseq.summary()# Human-readable summary                  #  'min_y': -40, 'max_y': 1560}                  #  'min_x': 67, 'max_x': 1667,                  #  'center_x': 867, 'center_y': 760,seq.get_bounds()  # {'width': 1600, 'height': 1600, # Bounds extraction (from JOB_HEADER)           #  'data_chunks': 0, 'estimated_time_sec': 22.0}seq.stats  # {'total_commands': 4, 'total_bytes': 200, # Statsseq.add(K6CommandBuilder.build_job_header(...))seq.add(K6CommandBuilder.build_framing())seq = CommandSequence(description="Test pattern")----[source,python]Job-level command collection:==== CommandSequence----checksum(packet: bytes) → int  # Two's complement 8-bit# Utilitybuild_init(number: int) → K6Commandbuild_data_packet(payload: bytes, line_num: int) → K6Commandbuild_job_header(width, height, depth, power, center_x=800, center_y=760) → K6Command# Burn sequence commandsbuild_version() → K6Commandbuild_crosshair(enable: bool) → K6Commandbuild_stop() → K6Commandbuild_home() → K6Commandbuild_bounds(width, height, center_x=800, center_y=760) → K6Commandbuild_connect(number: int) → K6Commandbuild_framing() → K6Command# Basic commands----[source,python]Factory class with **pure functions** (same input = same output, no side effects):==== K6CommandBuilder* `__repr__()` → Debug string* `to_dict()` → JSON-serializable dict for APIMethods:* `timestamp: float` - Auto-set from time.time()* `bytes_transferred: int` - Auto-calculated payload size* `phase: str` - CSV log phase (setup, burn, wait, etc.)* `timeout: float` - Response timeout* `expect_ack: bool` - Does this expect 0x09 ACK response?* `description: str` - Human-readable description* `payload: bytes` - Complete packet (opcode + length + data + checksum)* `opcode: K6Opcode` - Protocol opcodeCommand representation:==== K6Command (@dataclass)----# ... etcCROSSHAIR_OFF = 0x07 # Positioning laser offCROSSHAIR_ON = 0x06  # Positioning laser onSTOP = 0x16          # Emergency stopHOME = 0x17          # Return to originCONNECT = 0x0A       # HandshakeINIT = 0x24          # FinalizationJOB_HEADER = 0x23    # Burn parametersDATA = 0x22          # Raster line dataFRAMING = 0x21       # Stop preview, start burnBOUNDS = 0x20        # Preview rectangle (fast)VERSION = 0xFF       # Query firmware----[source,python]Protocol opcode constants:==== K6Opcode (IntEnum)=== Architecture|===| 238| Unit tests (no hardware needed)| `docker/tests/test_commands.py`| 426| Command abstraction layer| `docker/k6/commands.py`| File | Purpose | Lines|===[cols="1,2,1"]=== Core Files== What Was Built**Status**: Phase 1 foundation complete, ready for integration.Created preview-driven command abstraction layer for K6 driver testing without hardware.== SummaryShort. Small. Useful.

Purpose::
* Replace `k6_burn_image.py` with a clean, testable library and a tiny CLI.
* Remove duplicate logic and temporary shims; hard cutover when parity is verified.
* **Based on:** the K6 protocol described in the documentation (see `documentation/reference-k6_protocol.adoc`).

Approach::
* Write the library cleanly: small modules, pure functions, well-documented public API.
* Test first: unit tests for pure code, mock transport for protocol tests, integration parity tests against the legacy script.
* Keep runtime behavior identical where it matters (protocol framing, ACKs, status parsing, CSV format).

Use cases & requirements::
* Burn a raster image with configurable power and depth and produce CSV+JSON logs that match the legacy format.
* Burn vector-only jobs (circle points) and patterns (boundary, circle).
* Support `--no-burn` upload-only mode for timing analysis.
* Support replaying burns from a saved JSON config file.
* Stream raster payloads in chunks to avoid large memory use (DATA_CHUNK≈1900) and implement retry/backoff on no-ACK.
* Parse device status frames (FF FF 00 XX) and heartbeat frames (FF FF FF FE) and report progress (0–100%).
* Expose robust, testable SerialTransport abstraction with a `MockTransport` for unit tests.
* Preserve or document current defaults: `mm_per_px=0.05`, `max_width≈1600px`, `ACK=0x09`, `retry_limit=5`, `wait_per_line` and `min_wait` behavior.
* Provide deterministic filenames: `stat-YY-MM-DD-HH-MM(.csv/.json/.png)` and write error logs.
* Keep memory and CPU footprint small (Pi Zero). Stream data, do not allocate full payloads.

What's here::
* `driver.py` : new canonical driver (initially a direct rewrite of behavior; soon to use `transport.py`).
* `processing.py` : image math helpers (mm/px, sizing, margins).
* `logger.py` : config and image save helpers; will grow into CSV logger.
* `cli.py` : thin, minimal CLI for local testing.

Next steps (now)::
* Implement `transport.py` (SerialTransport + MockTransport) and unit tests.
* Port protocol functions (send_cmd, checksum, job header, payload builder, wait_for_completion) into library modules with tests.
* Add parity tests that run the same inputs through old script and new library and diff the CSV/JSON outputs.
* **Interface plan:** provide a tiny CLI first for reliability and testing, then expose the library via a web API for the UI and automation.
* Once parity is proven, switch CLI and web API to use the new library and archive `k6_burn_image.py`.
* Add CI (pytest) and small hardware integration job (optional, gated).

Dev: Virtualenv & packaging (idiot-proof)::
* Create a project venv and install the script deps (runs from repo root):

[source,bash]
----
# from repo root
bash scripts/setup_venv.sh
source scripts/venv/bin/activate
pip install --upgrade pip
# optional: install pre-commit hooks
pip install pre-commit ruff black
pre-commit install --install-hooks || true
# run quick tests
python3 scripts/run_unit_tests.py
# run full test suite (if you have pytest installed)
python3 -m pytest -q || true
----

* Packaging notes (for Docker/Pi Zero):
  * We will containerize the library later. For now, the Docker context is in `docker-wainlux/docker`.
  * To build on the Pi Zero, the Pi needs at least 1GB swap. See `docker-wainlux/README.adoc` for build hints.
  * Use `docker compose build` and `docker compose up -d` from `/docker-wainlux` to run the service.

* Tear-down and rebuild mantra (Hemingway):
  * Stop containers. Remove venv. Rebuild clean. Test quick. Repeat. Do not hoard state.
  * If something fails, the reproducer should be a short shell script that recreates the failure from scratch.

Design principles::
* KISS. DRY. Minimal public surface. Test first.

Priorities::
* Clean, human-readable code: short sentences, clear names, no unnecessary comment prose (Hemingway-style).
* No magic: explicit behavior, no hidden side-effects, predictable interfaces.
* Simple beats complex; easy beats fancy.
* Small, reviewed changes; perfect is the enemy of good.
* Keep functions tiny and testable; avoid global state and surprises.

Code style checklist (Hemingway):
* Keep it short: one idea per function; aim for 10–30 lines.
* Name plainly: nouns for classes, verbs for functions, no abbreviations.
* No magic numbers: name constants and explain why.
* Pure logic separate from side effects; side effects live in thin adapters.
* No global state: pass inputs, return outputs.
* Short docstrings: one-line summary, inputs, outputs.
* Tests for behavior, not implementation.
* Readability > cleverness.

Enforcement (light):
* Use `pre-commit` with `ruff` (lint) and `black` (format) to catch basic issues.
* Keep changes small and reviewed; use the checklist during code review.

Usage::
[source,bash]
----
# Draw boundary using the wrapper
scripts/k6/cli.py bounds --mm 75 --depth 5

# Engrave an image (calls existing script under the hood)
scripts/k6/cli.py engrave wifi.png --power 1000 --depth 10
----

== CSV Logging (NEW)

The new library includes built-in CSV logging that matches the legacy script format.

=== Quick Start

[source,python]
----
from scripts.k6.driver import WainluxK6
from scripts.k6.transport import SerialTransport
from scripts.k6.csv_logger import CSVLogger

driver = WainluxK6()
transport = SerialTransport("/dev/ttyUSB0", baudrate=115200)

# Use context manager for automatic file close
with CSVLogger("burn_log.csv") as logger:
    driver.connect_transport(transport, csv_logger=logger)
    result = driver.engrave_transport(
        transport, "image.png", 
        power=1000, depth=100,
        csv_logger=logger
    )
----

=== CSV Format

Each row captures timing, throughput, and retry metrics:

[source]
----
burn_start,timestamp,elapsed_s,phase,operation,duration_ms,
bytes_transferred,cumulative_bytes,throughput_kbps,status_pct,
state,response_type,retry_count,device_state
----

=== Logged Operations

* *Connect phase:* VERSION, CONNECT #1, CONNECT #2, HOME
* *Setup phase:* FRAMING, JOB_HEADER, pre-burn CONNECT
* *Burn phase:* DATA chunks (one row per chunk, retries logged separately)
* *Finalize phase:* INIT #1, INIT #2
* *Wait phase:* STATUS updates (progress 0–100%)

=== Example CSV Output

[source,csv]
----
burn_start,timestamp,elapsed_s,phase,operation,duration_ms,bytes_transferred,cumulative_bytes,throughput_kbps,status_pct,state,response_type,retry_count,device_state
2026-01-23 13:00:00,2026-01-23 13:00:00.100,0.100,connect,VERSION,45,7,7,0.15,,COMPLETE,OTHER,0,IDLE
2026-01-23 13:00:00,2026-01-23 13:00:00.150,0.150,connect,CONNECT #1,25,5,12,0.20,,COMPLETE,ACK,0,IDLE
2026-01-23 13:00:00,2026-01-23 13:00:00.200,0.200,connect,HOME,145,5,17,0.03,,COMPLETE,ACK,0,IDLE
2026-01-23 13:00:00,2026-01-23 13:00:01.000,1.000,setup,FRAMING,20,5,22,0.25,,COMPLETE,ACK,0,IDLE
2026-01-23 13:00:00,2026-01-23 13:00:01.050,1.050,burn,DATA line 0,180,1904,1926,10.22,,COMPLETE,ACK,0,IDLE
2026-01-23 13:00:00,2026-01-23 13:00:02.000,2.000,wait,STATUS,0,0,1926,,15,COMPLETE,STATUS,0,BURNING
2026-01-23 13:00:00,2026-01-23 13:00:10.000,10.000,wait,STATUS,0,0,1926,,100,COMPLETE,STATUS,0,COMPLETE
----

=== Testing

CSV logging is fully covered by unit tests. See `tests/test_csv_logging.py` for examples.

== Command Abstraction Layer (NEW)

=== Purpose

Separates command *generation* from *execution* to enable:

* **Preview**: Generate command sequence without hardware
* **Testing**: Unit test commands without serial device
* **Debugging**: Inspect exact bytes before burning
* **Validation**: Check bounds/limits before execution

See link:commands.py[commands.py] for implementation.

=== Key Classes

* **K6Opcode**: Protocol opcodes enum (VERSION=0xFF, BOUNDS=0x20, FRAMING=0x21, DATA=0x22, etc.)
* **K6Command**: Command dataclass with opcode, payload, description, metadata
* **K6CommandBuilder**: Factory methods for generating protocol commands (pure functions)
* **CommandSequence**: Collection of commands with stats tracking and bounds extraction

=== Quick Example

[source,python]
----
from k6.commands import K6CommandBuilder, CommandSequence

# Generate command sequence (no hardware needed)
seq = CommandSequence(description="Graph paper test")
seq.add(K6CommandBuilder.build_framing())
seq.add(K6CommandBuilder.build_job_header(1600, 1600, depth=100, power=500))

# Validate bounds before burning
bounds = seq.get_bounds()
if bounds['max_y'] > 1520:
    raise ValueError(f"Pattern exceeds Y-axis limit!")

# Get stats
print(f"Commands: {seq.stats['total_commands']}")
print(f"Est. time: {seq.stats['estimated_time_sec']}s")

# Serialize for API
json_data = seq.to_dict()
----

=== Testing

Run command abstraction tests without hardware:

[source,bash]
----
python3 tests/test_commands.py
----

See link:../../../../DRIVER_ABSTRACTION_PLAN.adoc[DRIVER_ABSTRACTION_PLAN.adoc] for full implementation roadmap.

