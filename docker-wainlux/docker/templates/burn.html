{% extends "base.html" %}
{% from "macros.html" import navigation, message_display %}

{% block title %}Burn Image{% endblock %}

{% block page_styles %}
.section { margin: 30px 0; }
.section h2 { margin-bottom: 15px; }
.burn-preview { text-align: center; margin: 20px 0; }
.burn-preview img { max-width: 400px; max-height: 400px; border: 1px solid #fff; }
.progress-section { margin: 20px 0; }
.progress-bar { 
    width: 100%; 
    height: 30px; 
    background: #1a1a1a; 
    border: 1px solid #fff; 
    position: relative; 
    margin: 10px 0;
}
.progress-fill { 
    height: 100%; 
    background: #4a4a4a; 
    transition: width 0.3s ease; 
    position: relative;
}
.progress-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #fff;
    font-weight: bold;
    z-index: 1;
}
.log-window {
    background: #000;
    border: 1px solid #fff;
    padding: 10px;
    height: 300px;
    overflow-y: auto;
    font-family: monospace;
    font-size: 12px;
    margin: 10px 0;
}
.log-entry {
    margin: 2px 0;
    color: #0f0;
}
.log-entry.error { color: #f00; }
.log-entry.warning { color: #ff0; }
.log-entry.info { color: #0ff; }
.job-info { 
    background: #1a1a1a; 
    padding: 15px; 
    border: 1px solid #fff; 
    margin: 10px 0;
}
.job-info h3 { margin-top: 0; }
.job-params { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
.stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; }
.stats-card { border: 1px solid #666; padding: 10px; background: #0a0a0a; }
.stats-card h4 { margin: 0 0 8px 0; }
.stats-meta { font-size: 0.9em; color: #aaa; margin-bottom: 8px; }
.stats-row { display: flex; justify-content: space-between; font-size: 0.9em; margin: 3px 0; }
.stats-actions { margin-top: 10px; display: flex; gap: 8px; }
.stats-actions button { background: #333; border: 1px solid #888; color: #fff; padding: 6px 10px; cursor: pointer; }
.stats-actions button:hover { background: #444; }
.stats-graph-panel { margin-top: 16px; border: 1px solid #666; background: #0a0a0a; padding: 12px; }
.stats-graph-controls { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; }
.stats-graph-controls select { background: #111; color: #fff; border: 1px solid #888; padding: 4px 8px; }
.stats-graph-canvas { width: 100%; min-height: 320px; background: linear-gradient(135deg, #ffffff 0%, #aaaaff 100%); border: 1px solid #333; }
.stats-graph-title { margin: 0 0 8px 0; color: #ddd; font-size: 0.95em; }
{% endblock %}

{% block content %}
{{ navigation("BURN IMAGE") }}

<div class="section" id="jobSection">
    <h2>BURN JOB</h2>
    
    <div class="job-info" id="jobInfo">
        <h3>Select What To Burn</h3>
        <div id="burnOptions" style="margin: 15px 0;">
            <!-- Checkboxes populated by JS based on available data -->
        </div>
        <div id="jobDetails" style="margin-top: 20px;"></div>
    </div>
    
    <div class="burn-preview">
        <h3>IMAGE PREVIEW</h3>
        <img id="jobImage" alt="Job preview">
        <div id="jobDimensions"></div>
    </div>
    
    <div style="margin: 20px 0;">
        <button id="btnBurn" style="font-size: 1.2em; padding: 15px 30px;">üî• START BURN</button>
        <button id="btnVerify" style="margin-left: 10px;">VERIFY K6</button>
        <button id="btnStop" style="display: none; margin-left: 10px;">‚èπ STOP</button>
        <button id="btnSaveJob" style="display: none; margin-left: 10px; background: #444;">üíæ SAVE JOB & LOGS</button>
    </div>
</div>

<div class="section" id="progressSection" style="display: none;">
    <h2>BURN PROGRESS</h2>
    
    <div class="progress-section">
        <label>SETUP & CONNECT:</label>
        <div class="progress-bar">
            <div id="progressSetup" class="progress-fill" style="width: 0%"></div>
            <div class="progress-text" id="progressSetupText">0%</div>
        </div>
    </div>
    
    <div class="progress-section">
        <label>IMAGE UPLOAD:</label>
        <div class="progress-bar">
            <div id="progressUpload" class="progress-fill" style="width: 0%"></div>
            <div class="progress-text" id="progressUploadText">0%</div>
        </div>
    </div>
    
    <div class="progress-section">
        <label>LASER BURNING:</label>
        <div class="progress-bar">
            <div id="progressBurn" class="progress-fill" style="width: 0%"></div>
            <div class="progress-text" id="progressBurnText">0%</div>
        </div>
    </div>
    
    <div class="log-window" id="logWindow"></div>
</div>

<div class="section" id="statsSection" style="display: none;">
    <h2>RUN STATS</h2>
    <div id="statsContent" class="stats-grid"></div>
    <div id="statsGraphPanel" class="stats-graph-panel" style="display:none;">
        <h3 id="statsGraphTitle" class="stats-graph-title">Run Graph</h3>
        <div class="stats-graph-controls">
            <label for="statsGraphType">Graph:</label>
            <select id="statsGraphType">
                <option value="timeline">Timeline</option>
                <option value="phase-bars">Phase Time Breakdown</option>
                <option value="status">Burn Status Progress</option>
            </select>
        </div>
        <canvas id="statsGraphCanvas" class="stats-graph-canvas" width="1080" height="360"></canvas>
    </div>
</div>

{{ message_display() }}
{% endblock %}

{% block page_script %}
    let currentJob = null;
    let eventSource = null;
    
    function cleanupProgressStream() {
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }
    }
    window.addEventListener('beforeunload', cleanupProgressStream);
    window.addEventListener('pagehide', cleanupProgressStream);
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
            cleanupProgressStream();
        }
    });
    
    const modeDisplay = document.getElementById('modeDisplay');
    const firmwareDisplay = document.getElementById('firmwareDisplay');
    const verifyDisplay = document.getElementById('verifyDisplay');
    const btnVerify = document.getElementById('btnVerify');
    const btnBurn = document.getElementById('btnBurn');
    const btnStop = document.getElementById('btnStop');
    const jobSection = document.getElementById('jobSection');
    const progressSection = document.getElementById('progressSection');
    const jobImage = document.getElementById('jobImage');
    const jobDimensions = document.getElementById('jobDimensions');
    const jobDetails = document.getElementById('jobDetails');
    const logWindow = document.getElementById('logWindow');
    const statsSection = document.getElementById('statsSection');
    const statsContent = document.getElementById('statsContent');
    const statsGraphPanel = document.getElementById('statsGraphPanel');
    const statsGraphTitle = document.getElementById('statsGraphTitle');
    const statsGraphType = document.getElementById('statsGraphType');
    const statsGraphCanvas = document.getElementById('statsGraphCanvas');
    const reportsByCsv = new Map();
    let activeGraphCsv = null;
    
    // Progress elements
    const progressSetup = document.getElementById('progressSetup');
    const progressSetupText = document.getElementById('progressSetupText');
    const progressUpload = document.getElementById('progressUpload');
    const progressUploadText = document.getElementById('progressUploadText');
    const progressBurn = document.getElementById('progressBurn');
    const progressBurnText = document.getElementById('progressBurnText');
    
    // Status bar functions now in shared api.js
    
    function addLog(message, type = 'info', eventTimestamp = null) {
        const sourceDate = eventTimestamp ? new Date(eventTimestamp) : new Date();
        const timestamp = formatLogTimestamp(sourceDate);
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.textContent = `[${timestamp}] ${message}`;
        logWindow.appendChild(entry);
        logWindow.scrollTop = logWindow.scrollHeight;
    }
    
    function updateProgress(phase, progress, message, eventTimestamp = null) {
        addLog(`${phase.toUpperCase()}: ${message}`, 'info', eventTimestamp);
        
        if (phase === 'setup' || phase === 'prepare' || phase === 'connect') {
            progressSetup.style.width = `${progress}%`;
            progressSetupText.textContent = `${progress}%`;
        } else if (phase === 'upload') {
            progressUpload.style.width = `${progress}%`;
            progressUploadText.textContent = `${progress}%`;
        } else if (phase === 'burning' || phase === 'wait' || phase === 'finalize') {
            progressBurn.style.width = `${progress}%`;
            progressBurnText.textContent = `${progress}%`;
        } else if (phase === 'complete') {
            progressSetup.style.width = '100%';
            progressSetupText.textContent = '100%';
            progressUpload.style.width = '100%';
            progressUploadText.textContent = '100%';
            progressBurn.style.width = '100%';
            progressBurnText.textContent = '100%';
            addLog('‚úì Burn complete!', 'info');
            btnBurn.disabled = false;
            btnStop.style.display = 'none';
        } else if (phase === 'error') {
            addLog(`ERROR: ${message}`, 'error');
            btnBurn.disabled = false;
            btnStop.style.display = 'none';
        } else if (phase === 'stopped') {
            addLog('‚èπ Burn stopped by user', 'warning');
            btnBurn.disabled = false;
            btnStop.style.display = 'none';
        }
    }

    async function postJobBurn(payload) {
        return apiCall('/api/job/burn', 'POST', payload);
    }

    function renderStatsCard(report) {
        const phaseRows = Object.entries(report.phase_stats || {})
            .map(([phase, s]) => `<div class="stats-row"><span>${phase}</span><span>${s.count} ops / ${(s.duration_ms/1000).toFixed(2)}s</span></div>`)
            .join('');
        const responseRows = Object.entries(report.response_counts || {})
            .map(([resp, count]) => `<div class="stats-row"><span>${resp}</span><span>${count}</span></div>`)
            .join('');
        const summary = report.summary || {};
        const timing = report.timing_summary || {};
        const finalStatus = timing.final_status_pct == null ? 'n/a' : `${timing.final_status_pct}%`;

        return `
            <div class="stats-card">
                <h4>${report.job_id || report.run_id || 'Run'}</h4>
                <div class="stats-meta">${report.csv_log}</div>
                <div class="stats-row"><span>Run ID</span><span>${report.run_id || 'n/a'}</span></div>
                <div class="stats-row"><span>Operations</span><span>${summary.operations || 0}</span></div>
                <div class="stats-row"><span>Total Time</span><span>${summary.total_elapsed_s || 0}s</span></div>
                <div class="stats-row"><span>Total Bytes</span><span>${summary.total_bytes || 0}</span></div>
                <div class="stats-row"><span>Avg Throughput</span><span>${summary.avg_throughput_kbps || 0} KB/s</span></div>
                <hr>
                <div style="font-weight:bold; margin-bottom:4px;">Phases</div>
                ${phaseRows || '<div class="stats-row"><span>n/a</span><span>0</span></div>'}
                <hr>
                <div style="font-weight:bold; margin-bottom:4px;">Responses</div>
                ${responseRows || '<div class="stats-row"><span>n/a</span><span>0</span></div>'}
                <hr>
                <div style="font-weight:bold; margin-bottom:4px;">Timing</div>
                <div class="stats-row"><span>Chunks</span><span>${timing.chunk_count || 0}</span></div>
                <div class="stats-row"><span>Chunk Avg</span><span>${timing.chunk_avg_ms || 0} ms</span></div>
                <div class="stats-row"><span>Chunk P95</span><span>${timing.chunk_p95_ms || 0} ms</span></div>
                <div class="stats-row"><span>Chunk Max</span><span>${timing.chunk_max_ms || 0} ms</span></div>
                <div class="stats-row"><span>Final Status</span><span>${finalStatus}</span></div>
                <div class="stats-actions">
                    <button type="button" data-action="graph" data-csv-log="${report.csv_log}">üìà Show Graph</button>
                </div>
            </div>
        `;
    }

    function resizeGraphCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const cssWidth = statsGraphCanvas.clientWidth || 1080;
        const cssHeight = 360;
        statsGraphCanvas.width = Math.floor(cssWidth * dpr);
        statsGraphCanvas.height = Math.floor(cssHeight * dpr);
        const ctx = statsGraphCanvas.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        return { ctx, width: cssWidth, height: cssHeight };
    }

    function drawAxes(ctx, width, height, margin, xLabel, yLabel) {
        const left = margin.left;
        const top = margin.top;
        const right = width - margin.right;
        const bottom = height - margin.bottom;

        ctx.strokeStyle = '#222';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(left, top);
        ctx.lineTo(left, bottom);
        ctx.lineTo(right, bottom);
        ctx.stroke();

        ctx.fillStyle = '#111';
        ctx.font = '12px monospace';
        ctx.fillText(xLabel, right - 80, bottom + 22);
        ctx.save();
        ctx.translate(14, (top + bottom) / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText(yLabel, 0, 0);
        ctx.restore();
        return { left, top, right, bottom };
    }

    function drawTimelineGraph(report) {
        const timeline = report?.timing?.timeline || [];
        const phases = Object.keys(report.phase_stats || {});
        const { ctx, width, height } = resizeGraphCanvas();
        const margin = { left: 64, right: 24, top: 20, bottom: 44 };
        ctx.clearRect(0, 0, width, height);
        const axis = drawAxes(ctx, width, height, margin, 'Time (s)', 'Phase');

        if (!timeline.length || !phases.length) {
            ctx.fillStyle = '#111';
            ctx.font = '14px monospace';
            ctx.fillText('No timeline data available for this run.', axis.left + 8, axis.top + 20);
            return;
        }

        const maxElapsed = Math.max(1, ...timeline.map(t => Number(t.elapsed_s || 0)));
        const phaseOrder = phases;
        const laneHeight = Math.max(14, Math.floor((axis.bottom - axis.top - 8) / phaseOrder.length));
        const phaseColors = {
            connect: '#ff9999',
            setup: '#ffcc99',
            prepare: '#ffcc99',
            upload: '#99ff99',
            burn: '#9999ff',
            wait: '#9999ff',
            finalize: '#9999ff'
        };

        phaseOrder.forEach((phase, idx) => {
            const y = axis.top + idx * laneHeight;
            ctx.fillStyle = '#111';
            ctx.font = '11px monospace';
            ctx.fillText(phase, 4, y + 11);
            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath();
            ctx.moveTo(axis.left, y + laneHeight);
            ctx.lineTo(axis.right, y + laneHeight);
            ctx.stroke();
        });

        for (const op of timeline) {
            const phase = op.phase || 'unknown';
            const phaseIdx = Math.max(0, phaseOrder.indexOf(phase));
            const start = Number(op.elapsed_s || 0);
            const durationSec = Math.max(0.001, Number(op.duration_ms || 0) / 1000.0);
            const x = axis.left + (start / maxElapsed) * (axis.right - axis.left);
            const w = Math.max(1, (durationSec / maxElapsed) * (axis.right - axis.left));
            const y = axis.top + phaseIdx * laneHeight + 2;
            ctx.fillStyle = phaseColors[phase] || '#ccc';
            ctx.fillRect(x, y, w, Math.max(3, laneHeight - 4));
        }

        ctx.fillStyle = '#111';
        ctx.font = '11px monospace';
        for (let i = 0; i <= 5; i++) {
            const t = (i / 5) * maxElapsed;
            const x = axis.left + (i / 5) * (axis.right - axis.left);
            ctx.fillText(t.toFixed(1), x - 10, axis.bottom + 14);
        }
    }

    function drawPhaseBarsGraph(report) {
        const phaseEntries = Object.entries(report.phase_stats || {});
        const { ctx, width, height } = resizeGraphCanvas();
        const margin = { left: 120, right: 20, top: 20, bottom: 44 };
        ctx.clearRect(0, 0, width, height);
        const axis = drawAxes(ctx, width, height, margin, 'Duration (s)', 'Phase');

        if (!phaseEntries.length) {
            ctx.fillStyle = '#111';
            ctx.font = '14px monospace';
            ctx.fillText('No phase duration data available for this run.', axis.left + 8, axis.top + 20);
            return;
        }

        const durationsSec = phaseEntries.map(([_, s]) => Number(s.duration_ms || 0) / 1000.0);
        const maxValue = Math.max(1, ...durationsSec);
        const barHeight = Math.max(12, Math.floor((axis.bottom - axis.top - 10) / phaseEntries.length) - 4);

        phaseEntries
            .sort((a, b) => (b[1].duration_ms || 0) - (a[1].duration_ms || 0))
            .forEach(([phase, s], idx) => {
                const value = Number(s.duration_ms || 0) / 1000.0;
                const y = axis.top + idx * (barHeight + 6);
                const w = (value / maxValue) * (axis.right - axis.left);
                ctx.fillStyle = '#3366cc';
                ctx.fillRect(axis.left, y, w, barHeight);
                ctx.fillStyle = '#111';
                ctx.font = '11px monospace';
                ctx.fillText(phase, 10, y + barHeight - 2);
                ctx.fillText(`${value.toFixed(2)}s`, axis.left + w + 6, y + barHeight - 2);
            });
    }

    function drawStatusGraph(report) {
        const statusSeries = report?.timing?.status_series || [];
        const { ctx, width, height } = resizeGraphCanvas();
        const margin = { left: 52, right: 20, top: 20, bottom: 44 };
        ctx.clearRect(0, 0, width, height);
        const axis = drawAxes(ctx, width, height, margin, 'Time (s)', 'Status %');

        if (!statusSeries.length) {
            ctx.fillStyle = '#111';
            ctx.font = '14px monospace';
            ctx.fillText('No burn status samples available for this run.', axis.left + 8, axis.top + 20);
            return;
        }

        const maxElapsed = Math.max(1, ...statusSeries.map(p => Number(p.elapsed_s || 0)));
        const xFor = (t) => axis.left + (t / maxElapsed) * (axis.right - axis.left);
        const yFor = (pct) => axis.bottom - (Math.max(0, Math.min(100, pct)) / 100) * (axis.bottom - axis.top);

        ctx.strokeStyle = '#cc3366';
        ctx.lineWidth = 2;
        ctx.beginPath();
        statusSeries.forEach((point, idx) => {
            const x = xFor(Number(point.elapsed_s || 0));
            const y = yFor(Number(point.pct || 0));
            if (idx === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.stroke();

        ctx.fillStyle = '#111';
        ctx.font = '11px monospace';
        for (let p = 0; p <= 100; p += 20) {
            const y = yFor(p);
            ctx.fillText(`${p}`, axis.left - 24, y + 4);
            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath();
            ctx.moveTo(axis.left, y);
            ctx.lineTo(axis.right, y);
            ctx.stroke();
        }
    }

    function renderGraphForReport(report) {
        if (!report) return;
        const graphType = statsGraphType.value;
        if (graphType === 'phase-bars') {
            drawPhaseBarsGraph(report);
        } else if (graphType === 'status') {
            drawStatusGraph(report);
        } else {
            drawTimelineGraph(report);
        }
    }

    function showGraphForCsv(csvLog) {
        const report = reportsByCsv.get(csvLog);
        if (!report) return;
        activeGraphCsv = csvLog;
        statsGraphTitle.textContent = `Run Graph: ${report.job_id || report.run_id || 'Unknown'} (${statsGraphType.value})`;
        statsGraphPanel.style.display = 'block';
        renderGraphForReport(report);
        statsGraphPanel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    async function loadReportsFromResults(results) {
        if (!results || results.length === 0) return;
        statsContent.innerHTML = '';
        statsSection.style.display = 'block';

        for (const result of results) {
            if (!result.csv_log) continue;
            try {
                const report = await apiCall('/api/reports/summary', 'POST', { csv_log: result.csv_log });
                report.job_id = result.job || report.job_id;
                reportsByCsv.set(report.csv_log, report);
                statsContent.insertAdjacentHTML('beforeend', renderStatsCard(report));
            } catch (err) {
                statsContent.insertAdjacentHTML(
                    'beforeend',
                    `<div class="stats-card"><h4>${result.job || 'job'}</h4><div class="stats-meta">Failed to load report: ${err.message}</div></div>`
                );
            }
        }
    }
    
    async function loadJob() {
        const saved = getMaterialConfig();
        if (!saved) {
            // No saved job - create default job with default image and material
            addLog('No saved job found - loading defaults', 'info');
            await loadDefaultJob();
            return;
        }
        
        currentJob = saved;
        
        // Ensure image exists via shared ingest path while preserving existing job data.
        try {
            const { addedDefault } = await ensureJobHasUploadImage(currentJob, {
                source: 'default',
                sourceReference: '/api/images/serve/default-image.png',
            });
            if (addedDefault) {
                addLog('Saved job had no image; default image injected', 'warning');
            }
        } catch (err) {
            addLog(`Could not ensure job image: ${err.message}`, 'warning');
            await loadDefaultJob();
            return;
        }
        
        displayJob();
    }
    
    async function loadDefaultJob() {
        try {
            const materialsData = await apiCall('/api/materials/list', 'GET');
            let defaultMaterial = materialsData.materials.find(m => m.id === 'default');

            if (!defaultMaterial) {
                defaultMaterial = materialsData.materials.find(m => m.type === 'base_material');
                addLog('Default material not found, using first base material', 'warning');
            }

            if (!defaultMaterial) {
                showMessage('No materials found. Cannot create default job.', true);
                addLog('No materials available', 'error');
                return;
            }

            currentJob = {
                version: '1.0',
                stages: {},
                material: {
                    type: 'base',
                    material_id: defaultMaterial.id,
                    name: defaultMaterial.name,
                    power: defaultMaterial.power,
                    depth: defaultMaterial.depth,
                    repeat: defaultMaterial.repeat || 1
                },
                layout: {
                    position: { x: 800, y: 800 }  // Default center position
                }
            };

            const { addedDefault } = await ensureJobHasUploadImage(currentJob, {
                source: 'default',
                sourceReference: '/api/images/serve/default-image.png',
            });
            if (addedDefault) {
                addLog('Default image loaded via shared ingest path', 'info');
            }
            addLog(`Default job created: ${defaultMaterial.name}, center position (800, 800)`, 'info');
            displayJob();
        } catch (err) {
            showMessage('Failed to load default job: ' + err.message, true);
            addLog('Failed to load defaults: ' + err.message, 'error');
        }
    }
    
    function displayJob() {
        const uploadData = currentJob.stages.upload.data;
        const material = currentJob.material || {};
        const layout = currentJob.layout || {};
        
        // Build burn options based on available data
        let options = '';
        
        if (material.type === 'object') {
            // OBJECT MODE: Three burn options (radio buttons - mutually exclusive)
            
            // Option 1: Image on backing material (test)
            if (material.backing) {
                options += `
                    <label style="display: block; margin: 10px 0; padding: 10px; border: 1px solid #666; cursor: pointer;">
                        <input type="radio" name="burnOption" value="image-backing" checked>
                        <strong>Image on Backing Material (test)</strong><br>
                        <span style="color: #aaa; font-size: 0.9em;">
                            Burn ${uploadData.original_filename || 'image'} at calculated position<br>
                            Material: ${material.backing.name} @ ${material.backing.power}W/${material.backing.depth}D<br>
                            Purpose: Test image placement before final burn
                        </span>
                    </label>
                `;
            }
            
            // Option 2: Alignment box on backing
            if (material.target && material.backing) {
                options += `
                    <label style="display: block; margin: 10px 0; padding: 10px; border: 1px solid #666; cursor: pointer;">
                        <input type="radio" name="burnOption" value="alignment">
                        <strong>Alignment Box on Backing</strong><br>
                        <span style="color: #aaa; font-size: 0.9em;">
                            Burn ${material.target.width_mm}√ó${material.target.height_mm}mm frame<br>
                            Material: ${material.backing.name} @ ${material.backing.power}W/${material.backing.depth}D<br>
                            Purpose: Physical guide for object placement<br>
                            Border width: <input type="number" id="alignmentBorderWidth" min="1" max="10" value="3" style="width: 50px; margin-top: 5px;"> px
                        </span>
                    </label>
                `;
            }
            
            // Option 3: Combined alignment box + image on backing (FAST)
            if (material.target && material.backing) {
                options += `
                    <label style="display: block; margin: 10px 0; padding: 10px; border: 1px solid #666; cursor: pointer;">
                        <input type="radio" name="burnOption" value="combined">
                        <strong>Alignment Box + Image on Backing (FAST)</strong><br>
                        <span style="color: #aaa; font-size: 0.9em;">
                            Burn ${material.target.width_mm}√ó${material.target.height_mm}mm frame + ${uploadData.original_filename || 'image'}<br>
                            Material: ${material.backing.name} @ ${material.backing.power}W/${material.backing.depth}D<br>
                            Purpose: Combined test - single burn saves time<br>
                            Border width: <input type="number" id="combinedBorderWidth" min="1" max="10" value="3" style="width: 50px; margin-top: 5px;"> px
                        </span>
                    </label>
                `;
            }
            
            // Option 4: Image on object (final)
            if (material.target) {
                options += `
                    <label style="display: block; margin: 10px 0; padding: 10px; border: 1px solid #666; cursor: pointer;">
                        <input type="radio" name="burnOption" value="image-object">
                        <strong>Image on Object (final)</strong><br>
                        <span style="color: #aaa; font-size: 0.9em;">
                            Burn ${uploadData.original_filename || 'image'} at calculated position<br>
                            Material: ${material.target.material} @ ${material.target.power}W/${material.target.depth}D<br>
                            Purpose: Final burn on positioned object
                        </span>
                    </label>
                `;
            }
        } else {
            // SIMPLE MODE: Single image burn
            options = `
                <label style="display: block; margin: 10px 0; padding: 10px; border: 1px solid #666;">
                    <input type="radio" name="burnOption" value="image-simple" checked disabled>
                    <strong>Burn image on base material</strong><br>
                    <span style="color: #aaa; font-size: 0.9em;">
                        ${uploadData.original_filename || 'Image'} - ${material.backing?.name || 'Default settings'}<br>
                        (${material.backing?.power || 1000}W, ${material.backing?.depth || 100}D)
                    </span>
                </label>
            `;
        }
        
        document.getElementById('burnOptions').innerHTML = options;
        attachBurnOptionPreviewHandlers();
        
        // Summary details
        let details = `
            <div style="border-top: 1px solid #666; padding-top: 15px; margin-top: 15px;">
                <strong>Image:</strong> ${uploadData.original_filename || 'Unknown'} (${uploadData.width}√ó${uploadData.height}px)
        `;
        if (uploadData.resized && uploadData.original_width && uploadData.original_height) {
            details += `<br><strong>Image Resize:</strong> scaled from ${uploadData.original_width}√ó${uploadData.original_height}px to ${uploadData.width}√ó${uploadData.height}px`;
        }
        if (uploadData.source) {
            details += `<br><strong>Image Source:</strong> ${uploadData.source}`;
        }
        if (uploadData.source_reference) {
            details += `<br><strong>Source Reference:</strong> ${uploadData.source_reference}`;
        }

        if (material.target) {
            details += `<br><strong>Object:</strong> ${material.target.shape || 'Custom'} (${material.target.width_mm}√ó${material.target.height_mm}mm)`;
        }
        
        if (layout.material_on_burn_area) {
            details += `<br><strong>Material Position:</strong> (${layout.material_on_burn_area.center_x_mm}, ${layout.material_on_burn_area.center_y_mm})mm`;
        }
        
        if (layout.image_on_material) {
            details += `<br><strong>Image on Material:</strong> (${layout.image_on_material.center_x_mm}, ${layout.image_on_material.center_y_mm})mm offset`;
        }
        
        details += `</div>`;
        jobDetails.innerHTML = details;
        
        jobSection.style.display = 'block';
        refreshBurnPlanPreview();
    }

    function buildBurnJobsFromSelection(selected) {
        const material = currentJob.material || {};
        const burnJobs = {};
        const alignmentBorderRaw = Number.parseInt(document.getElementById('alignmentBorderWidth')?.value ?? '3', 10);
        const combinedBorderRaw = Number.parseInt(document.getElementById('combinedBorderWidth')?.value ?? '3', 10);
        const alignmentBorder = Number.isFinite(alignmentBorderRaw) ? Math.max(1, Math.min(10, alignmentBorderRaw)) : 3;
        const combinedBorder = Number.isFinite(combinedBorderRaw) ? Math.max(1, Math.min(10, combinedBorderRaw)) : 3;

        selected.forEach((burnType) => {
            if (burnType === 'alignment') {
                burnJobs.alignment = {
                    enabled: true,
                    power: material.backing?.power || 500,
                    depth: material.backing?.depth || 10,
                    center_strategy: 'material_only',
                    render_spec: {
                        mode: 'bounds',
                        border_width: alignmentBorder
                    }
                };
            } else if (burnType === 'combined') {
                burnJobs.combined = {
                    enabled: true,
                    power: material.backing?.power || 500,
                    depth: material.backing?.depth || 10,
                    center_strategy: 'material_only',
                    render_spec: {
                        mode: 'combined',
                        border_width: combinedBorder
                    }
                };
            } else if (burnType === 'image-backing') {
                burnJobs.image_on_backing = {
                    enabled: true,
                    power: material.backing?.power || 500,
                    depth: material.backing?.depth || 10,
                    center_strategy: 'material_plus_image',
                    render_spec: { mode: 'image' }
                };
            } else if (burnType === 'image-object') {
                burnJobs.image_on_object = {
                    enabled: true,
                    power: material.target?.power || 500,
                    depth: material.target?.depth || 10,
                    center_strategy: 'material_plus_image',
                    render_spec: { mode: 'image' }
                };
            } else if (burnType === 'image-simple') {
                burnJobs.image_on_base = {
                    enabled: true,
                    power: material.backing?.power || material.power || 1000,
                    depth: material.backing?.depth || material.depth || 100,
                    center_strategy: 'material_plus_image',
                    render_spec: { mode: 'image' }
                };
            }
        });

        return burnJobs;
    }

    function attachBurnOptionPreviewHandlers() {
        document.querySelectorAll('input[name="burnOption"]').forEach((el) => {
            el.addEventListener('change', refreshBurnPlanPreview);
        });
        const alignmentBorder = document.getElementById('alignmentBorderWidth');
        const combinedBorder = document.getElementById('combinedBorderWidth');
        if (alignmentBorder) alignmentBorder.addEventListener('input', refreshBurnPlanPreview);
        if (combinedBorder) combinedBorder.addEventListener('input', refreshBurnPlanPreview);
    }

    async function refreshBurnPlanPreview() {
        if (!currentJob || !currentJob.stages?.upload?.data) return;

        const selected = Array.from(document.querySelectorAll('input[name="burnOption"]:checked'))
            .map(cb => cb.value);
        if (selected.length === 0) return;

        try {
            const burnJobs = buildBurnJobsFromSelection(selected);
            const previewPayload = {
                job: {
                    ...currentJob,
                    burn_jobs: burnJobs
                }
            };

            const data = await apiCall('/api/job/preview', 'POST', previewPayload);
            const primary = (data.previews || [])[0];
            if (!primary) return;

            jobImage.src = primary.preview_image;
            jobDimensions.textContent =
                `${primary.width} √ó ${primary.height}px | center=(${primary.center_x ?? 'auto'}, ${primary.center_y ?? 'auto'}) | ` +
                `P${primary.power}/D${primary.depth} | chunks‚âà${primary.estimate.total_chunks}`;
        } catch (err) {
            addLog(`Preview update failed: ${err.message}`, 'warning');
        }
    }
    
    btnVerify.addEventListener('click', async () => {
        try {
            addLog('Verifying K6 connection...', 'info');
            const data = await verifyConnectionAndRefreshStatus();
            addLog(`‚úì K6 ${data.version || ''} verified`, 'info');
            showMessage(`K6 ${data.version || ''} verified`);
        } catch (err) {
            showMessage('Verification failed: ' + err.message, true);
            addLog('‚úó Verification failed: ' + err.message, 'error');
        }
    });
    
    btnBurn.addEventListener('click', async () => {
        if (!currentJob) {
            showMessage('No job loaded', true);
            return;
        }
        
        // Get selected burn options
        const selected = Array.from(document.querySelectorAll('input[name="burnOption"]:checked'))
            .map(cb => cb.value);
        
        if (selected.length === 0) {
            showMessage('Please select at least one burn option', true);
            return;
        }
        
        if (!confirm(`Start burning ${selected.length} job(s)? This will activate the laser!`)) {
            return;
        }
        
        btnBurn.disabled = true;
        btnStop.style.display = 'inline-block';
        progressSection.style.display = 'block';
        
        // Reset progress
        progressSetup.style.width = '0%';
        progressSetupText.textContent = '0%';
        progressUpload.style.width = '0%';
        progressUploadText.textContent = '0%';
        progressBurn.style.width = '0%';
        progressBurnText.textContent = '0%';
        logWindow.innerHTML = '';
        statsSection.style.display = 'none';
        statsContent.innerHTML = '';
        statsGraphPanel.style.display = 'none';
        reportsByCsv.clear();
        activeGraphCsv = null;
        
        addLog(`Starting ${selected.length} burn job(s)...`, 'info');
        
        // Setup SSE for progress updates
        eventSource = new EventSource('/api/progress/stream');
        eventSource.onmessage = (event) => {
            const data = JSON.parse(event.data);
            updateProgress(data.phase, data.progress, data.message, data.timestamp);
        };
        
        eventSource.onerror = cleanupProgressStream;
        
        try {
            selected.forEach((burnType, index) => {
                addLog(`\n=== Queue ${index + 1}/${selected.length}: ${burnType} ===`, 'info');
            });
            const burnJobs = buildBurnJobsFromSelection(selected);

            const burnPayload = {
                job: {
                    ...currentJob,
                    burn_jobs: burnJobs
                }
            };

            addLog(`Submitting ${Object.keys(burnJobs).length} job(s) to server renderer...`, 'info');
            const result = await postJobBurn(burnPayload);

            lastBurnTimestamp = new Date().toISOString().replace(/[:.]/g, '-');
            lastBurnResult = result;
            btnSaveJob.style.display = 'inline-block';

            (result.results || []).forEach((r, idx) => {
                if (r.success) {
                    addLog(`‚úì Burn ${idx + 1} (${r.job}) complete in ${r.total_time}s`, 'info');
                } else {
                    addLog(`‚úó Burn ${idx + 1} (${r.job}) failed: ${r.error || r.message}`, 'error');
                }
            });

            await loadReportsFromResults(result.results || []);

            showMessage('All burns complete!');
            btnBurn.disabled = false;
            btnStop.style.display = 'none';
            
        } catch (err) {
            addLog(`‚úó Burn failed: ${err.message}`, 'error');
            showMessage('Burn failed: ' + err.message, true);
            btnBurn.disabled = false;
            btnStop.style.display = 'none';
            
            lastBurnTimestamp = new Date().toISOString().replace(/[:.]/g, '-');
            lastBurnResult = { success: false, error: err.message, details: err.data || null };
            btnSaveJob.style.display = 'inline-block';
            if (err.data && Array.isArray(err.data.results)) {
                await loadReportsFromResults(err.data.results);
            }
        } finally {
            cleanupProgressStream();
        }
    });

    statsContent.addEventListener('click', (event) => {
        const btn = event.target.closest('button[data-action="graph"]');
        if (!btn) return;
        const csvLog = btn.getAttribute('data-csv-log');
        if (!csvLog) return;
        showGraphForCsv(csvLog);
    });

    statsGraphType.addEventListener('change', () => {
        if (!activeGraphCsv) return;
        const report = reportsByCsv.get(activeGraphCsv);
        statsGraphTitle.textContent = `Run Graph: ${report?.job_id || report?.run_id || 'Unknown'} (${statsGraphType.value})`;
        renderGraphForReport(report);
    });

    window.addEventListener('resize', () => {
        if (!activeGraphCsv || statsGraphPanel.style.display === 'none') return;
        renderGraphForReport(reportsByCsv.get(activeGraphCsv));
    });
    
    btnStop.addEventListener('click', async () => {
        if (!confirm('Stop burning? This will interrupt the current operation.')) {
            return;
        }
        
        try {
            await apiCall('/api/test/stop', 'POST');
            addLog('Stop signal sent', 'warning');
            cleanupProgressStream();
        } catch (err) {
            addLog(`Stop failed: ${err.message}`, 'error');
        }
    });
    
    // Save Job & Logs functionality
    const btnSaveJob = document.getElementById('btnSaveJob');
    let lastBurnTimestamp = null;
    let lastBurnResult = null;
    
    btnSaveJob.addEventListener('click', () => {
        if (!currentJob) {
            showMessage('No job to save', true);
            return;
        }
        
        const timestamp = lastBurnTimestamp || new Date().toISOString().replace(/[:.]/g, '-');
        
        // Save job configuration as JSON
        const jobData = {
            timestamp: timestamp,
            job: currentJob,
            result: lastBurnResult,
            logs: Array.from(document.querySelectorAll('#logWindow .log-entry')).map(el => el.textContent)
        };
        
        const jobBlob = new Blob([JSON.stringify(jobData, null, 2)], { type: 'application/json' });
        const jobUrl = URL.createObjectURL(jobBlob);
        const jobLink = document.createElement('a');
        jobLink.href = jobUrl;
        jobLink.download = `k6-burn-job-${timestamp}.json`;
        jobLink.click();
        URL.revokeObjectURL(jobUrl);
        
        // Save logs as text file
        const logsText = jobData.logs.join('\n');
        const logsBlob = new Blob([logsText], { type: 'text/plain' });
        const logsUrl = URL.createObjectURL(logsBlob);
        const logsLink = document.createElement('a');
        logsLink.href = logsUrl;
        logsLink.download = `k6-burn-logs-${timestamp}.txt`;
        logsLink.click();
        URL.revokeObjectURL(logsUrl);
        
        showMessage('Job and logs saved');
    });
    
    // Initial load
    refreshStatus();
    loadJob();
{% endblock %}
